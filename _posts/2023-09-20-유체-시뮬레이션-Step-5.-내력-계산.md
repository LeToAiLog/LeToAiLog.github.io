---
title: 유체 시뮬레이션 Step 5. Internal force calculation
description: 유체 시뮬레이션(Smoothed Particle Hydrodynamics)을 구현하기 위한 다섯 번째 걸음
date: 2023-09-20 23:15:30 +09:00
categories: [Smoothed Particle Hydrodynamics]
tags: [Smoothed Particle Hydrodynamics, fluid simulation, physics simulation, 유체 시뮬레이션, fluid, 유체, 물리 시뮬레이션, 입자 시뮬레이션, Particles, 입자, SPH]
pin: true
math: true
mermaid: true
image:
  path: /assets/img/smoothed-particle-hydrodynamics/internal-forcel-image.png
  # 대표 이미지의 애니메이션 적용
  lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
  alt:
---
<!--  -->
# **Internal force**
<hr>

## Internal force calculation <br>

내력에는 **`Pressure force`**와 **`Viscous force`**가 있다.

<span style="color: rgb(255,128,0)"><code><big><b>External force</b></big></code></span>와 <span style="color: rgb(255,128,0)"><code><big><b>internal force</b></big></code></span>의 계산은 각각 독립적으로 진행할 수 있다.

그 이유는 **`External force`**와 **`internal force`**는 속성(Properties)을 교환하지 않기 때문이다. 따라서 미리 계산된 `Density`와 상태 방정식으로 계산된 `Pressure`를 사용하여 독립적으로 계산하며, 이는 병렬 처리를 통해 가속할 수 있다.

먼저 `Pressure force`를 구현하기 전에 주의해야 할 점이 있다.
`Kernel function`으로부터 `Pressure force`를 계산할 때 `Kernel`의 `Gradient` 중심에서 0에 가까워지기 때문에 반발력(`Repulsive force`)가 사라지는 문제가 있다.

따라서 `Kernel function`을 설계할 때는 이러한 문제를 인지하고 해결책을 제안한 Desbrun의 `Spiky kernel`을 구현에 사용해야 한다.
다음은 Desbrun이 디자인한 `Spiky kernel`이다.

$$
\begin{aligned}
  W_{spiky}(r, h) &= \frac{15}{\pi h^{6}}
  \left\{\begin{matrix}
  (h-r)^{3} & 0\leq r\leq h\\ 
  0 & otherwise,
  \end{matrix}\right.
\end{aligned}
$$

```python
def pressKernelGradient(diffX, diffY, diffZ, r, d):
    dist = sqrt((diffX * diffX) + (diffY * diffY) + (diffZ * diffZ))
    a = (45.0 / (PI * pow(r, 6.0))) * pow(r - dist, 2.0)
    norm = sqrt(1.0 * 1.0 + 1.0 * 1.0 + 1.0 * 1.0)
    grad = 1.0 / norm

    if dist > r:
        return 0.0
    elif dist < 10e-5:
        return -((grad * a))
    else:
        if d == 1:
            diff = diffX / dist
        if d == 2:
            diff = diffY / dist
        if d == 3:
            diff = diffZ / dist
        return -(diff * a)
```

여기서 `diff`는 `x`, `y`, `z`축으로 구분되며, `d`는 `diff`에서 `x`, `y`, `z`에 해당하는 값을 저장하는 역할을 하는 차원이다.

<hr>

### **분류**
<hr>

<!-- 이미지 -->
<!-- ![평활 입자 유체역학 커널 그림](/assets/img/smoothed-particle-hydrodynamics/SmoothingKernelFigurewithWhiteBackground.png){:width="500" height="589" style="border:1px solid #eaeaea; border-radius: 10px; padding: 0px;"} 
_**<span style="color:deepskyblue; font-size:150%">Figure 1. </span>
<span style="color:gainsboro;font-size:150%">Particle approximation using particles within the particle range(ℎ), 𝑘ℎ is the particle range, $$r_{ij}$$ is the distance between the neighbor particle and the central particle(red).</span>**_ -->